From 923712ed0bc27d5a43d66743388e888f1a7273ca Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andreas=20B=C3=BCrkler?= <andreas.buerkler@enclustra.com>
Date: Tue, 26 Jul 2022 20:56:08 +0200
Subject: [PATCH] SPI driver updated

---
 drivers/spi/spi-microsemi.c | 1053 ++++++++++++++---------------------
 1 file changed, 419 insertions(+), 634 deletions(-)

diff --git a/drivers/spi/spi-microsemi.c b/drivers/spi/spi-microsemi.c
index 493793a6ac24..d497b7c0d335 100644
--- a/drivers/spi/spi-microsemi.c
+++ b/drivers/spi/spi-microsemi.c
@@ -1,834 +1,619 @@
+// SPDX-License-Identifier: (GPL-2.0)
 /*
- * SPI controller driver for Microsemi MSS SPI
+ * Microchip CoreSPI SPI controller driver
  *
- * Copyright (c) 2018 Microsemi Corporation.
+ * Copyright (c) 2018-2022 Microchip Technology Inc. and its subsidiaries
  *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 2 of the License, or
- * (at your option) any later version.
+ * Author: Daire McNamara <daire.mcnamara@microchip.com>
+ * Author: Conor Dooley <conor.dooley@microchip.com>
  *
- * Based on spi_mss.c by Emcraft Systems
  */
 
-#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/spi/spi.h>
-#include <linux/err.h>
-#include <linux/clk.h>
 #include <linux/io.h>
-#include <linux/delay.h>
+#include <linux/module.h>
 #include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
 
-/*
- * Maximum size we allow per xfer (limited with txrxdf_count register)
- */
-#define MSS_SPI_MAX_LEN			(0xffff)
-
-#define MSS_SPI_MAX_CS			(8)
-
-#define MSS_SPI_FIFO_DEPTH		(32)
-
-#define MSS_SPI_CLK_GEN_MAX		(255)
-#define MSS_SPI_CLK_GEN_P2_MAX		(15)
-#define MSS_SPI_CLK_GEN_MIN		(0)
-
-#define MSS_SPI_CONTROL_ENABLE		(1 << 0)
-#define MSS_SPI_CONTROL_MASTER		(1 << 1)
-#define MSS_SPI_CONTROL_PROTO_MSK	(3 << 2)
-#define MSS_SPI_CONTROL_PROTO_MOTO	(0 << 2)
-#define MSS_SPI_CONTROL_RX_DATA_INT     (1 << 4)
-#define MSS_SPI_CONTROL_TX_DATA_INT     (1 << 5)
-#define MSS_SPI_CONTROL_RX_OVER_INT     (1 << 6)
-#define MSS_SPI_CONTROL_TX_UNDER_INT    (1 << 7)
-#define MSS_SPI_CONTROL_CNT_MSK		(0xffff << 8)
-#define MSS_SPI_CONTROL_CNT_SHF		(8)
-#define MSS_SPI_CONTROL_SPO		(1 << 24)
-#define MSS_SPI_CONTROL_SPH		(1 << 25)
-#define MSS_SPI_CONTROL_SPS		(1 << 26)
-#define MSS_SPI_CONTROL_FRAMEURUN       (1 << 27)
-#define MSS_SPI_CONTROL_CLKMODE		(1 << 28)
-#define MSS_SPI_CONTROL_BIGFIFO		(1 << 29)
-#define MSS_SPI_CONTROL_OENOFF		(1 << 30)
-#define MSS_SPI_CONTROL_RESET		(1 << 31)
-
-#define MSS_SPI_STATUS_ACTIVE			(1 << 14)
-#define MSS_SPI_STATUS_SSEL			(1 << 13)
-#define MSS_SPI_STATUS_FRAMESTART		(1 << 12)
-#define MSS_SPI_STATUS_TXFIFO_EMPTY_NEXT_READ	(1 << 11)
-#define MSS_SPI_STATUS_TXFIFO_EMPTY		(1 << 10)
-#define MSS_SPI_STATUS_TXFIFO_FULL_NEXT_WRITE	(1 << 9)
-#define MSS_SPI_STATUS_TXFIFO_FULL		(1 << 8)
-#define MSS_SPI_STATUS_RXFIFO_EMPTY_NEXT_READ	(1 << 7)
-#define MSS_SPI_STATUS_RXFIFO_EMPTY		(1 << 6)
-#define MSS_SPI_STATUS_RXFIFO_FULL_NEXT_WRITE	(1 << 5)
-#define MSS_SPI_STATUS_RXFIFO_FULL		(1 << 4)
-#define MSS_SPI_STATUS_TX_UNDERRUN		(1 << 3)
-#define MSS_SPI_STATUS_RX_OVERFLOW		(1 << 2)
-#define MSS_SPI_STATUS_RXDAT_RCED		(1 << 1)
-#define MSS_SPI_STATUS_TXDAT_SENT		(1 << 0)
-
-#define MSS_SPI_INT_TXDONE		(1 << 0)
-#define MSS_SPI_INT_RXRDY		(1 << 1)
-#define MSS_SPI_INT_RX_CH_OVRFLW	(1 << 2)
-#define MSS_SPI_INT_TX_CH_UNDRUN	(1 << 3)
-#define MSS_SPI_INT_CMD			(1 << 4)
-#define MSS_SPI_INT_SSEND		(1 << 5)
-
-/*
- * Private data structure for an SPI slave
- */
-struct mss_spi_dsc {
+#define MAX_LEN				(0xffff)
+#define MAX_CS				(8)
+#define DEFAULT_FRAMESIZE		(8)
+#define FIFO_DEPTH			(32)
+#define CLK_GEN_MODE1_MAX		(255)
+#define CLK_GEN_MODE0_MAX		(15)
+#define CLK_GEN_MIN			(0)
+#define MODE_X_MASK_SHIFT		(24)
+
+#define CONTROL_ENABLE			BIT(0)
+#define CONTROL_MASTER			BIT(1)
+#define CONTROL_RX_DATA_INT		BIT(4)
+#define CONTROL_TX_DATA_INT		BIT(5)
+#define CONTROL_RX_OVER_INT		BIT(6)
+#define CONTROL_TX_UNDER_INT		BIT(7)
+#define CONTROL_SPO			BIT(24)
+#define CONTROL_SPH			BIT(25)
+#define CONTROL_SPS			BIT(26)
+#define CONTROL_FRAMEURUN		BIT(27)
+#define CONTROL_CLKMODE			BIT(28)
+#define CONTROL_BIGFIFO			BIT(29)
+#define CONTROL_OENOFF			BIT(30)
+#define CONTROL_RESET			BIT(31)
+
+#define CONTROL_MODE_MASK		GENMASK(3, 2)
+#define  MOTOROLA_MODE			(0)
+#define CONTROL_FRAMECNT_MASK		GENMASK(23, 8)
+#define CONTROL_FRAMECNT_SHIFT		(8)
+
+#define STATUS_ACTIVE			BIT(14)
+#define STATUS_SSEL			BIT(13)
+#define STATUS_FRAMESTART		BIT(12)
+#define STATUS_TXFIFO_EMPTY_NEXT_READ	BIT(11)
+#define STATUS_TXFIFO_EMPTY		BIT(10)
+#define STATUS_TXFIFO_FULL_NEXT_WRITE	BIT(9)
+#define STATUS_TXFIFO_FULL		BIT(8)
+#define STATUS_RXFIFO_EMPTY_NEXT_READ	BIT(7)
+#define STATUS_RXFIFO_EMPTY		BIT(6)
+#define STATUS_RXFIFO_FULL_NEXT_WRITE	BIT(5)
+#define STATUS_RXFIFO_FULL		BIT(4)
+#define STATUS_TX_UNDERRUN		BIT(3)
+#define STATUS_RX_OVERFLOW		BIT(2)
+#define STATUS_RXDAT_RXED		BIT(1)
+#define STATUS_TXDAT_SENT		BIT(0)
+
+#define INT_TXDONE			BIT(0)
+#define INT_RXRDY			BIT(1)
+#define INT_RX_CHANNEL_OVERFLOW		BIT(2)
+#define INT_TX_CHANNEL_UNDERRUN		BIT(3)
+
+#define INT_ENABLE_MASK (CONTROL_RX_DATA_INT | CONTROL_TX_DATA_INT | \
+			 CONTROL_RX_OVER_INT | CONTROL_TX_UNDER_INT)
+
+#define REG_CONTROL		(0x00)
+#define REG_FRAME_SIZE		(0x04)
+#define REG_STATUS		(0x08)
+#define REG_INT_CLEAR		(0x0c)
+#define REG_RX_DATA		(0x10)
+#define REG_TX_DATA		(0x14)
+#define REG_CLK_GEN		(0x18)
+#define REG_SLAVE_SELECT	(0x1c)
+#define  SSEL_MASK		GENMASK(7, 0)
+#define  SSEL_DIRECT		BIT(8)
+#define  SSELOUT_SHIFT		9
+#define  SSELOUT		BIT(SSELOUT_SHIFT)
+#define REG_MIS			(0x20)
+#define REG_RIS			(0x24)
+#define REG_CONTROL2		(0x28)
+#define REG_COMMAND		(0x2c)
+#define REG_PKTSIZE		(0x30)
+#define REG_CMD_SIZE		(0x34)
+#define REG_HWSTATUS		(0x38)
+#define REG_STAT8		(0x3c)
+#define REG_CTRL2		(0x48)
+#define REG_FRAMESUP		(0x50)
+
+struct mchp_corespi {
 	void __iomem *regs;
-	int irq;
 	struct clk *clk;
-	u8 clk_gen;
-	u8 clk_mode;
 	const u8 *tx_buf;
 	u8 *rx_buf;
+	u32 clk_gen; /* divider for spi output clock generated by the controller */
+	u32 clk_mode;
+	int irq;
 	int tx_len;
 	int rx_len;
 	int pending;
 };
 
-/*
- * Description of the the SmartFusion SPI hardware interfaces.
- * This is a 1-to-1 mapping of Actel's documentation onto a C structure.
- * Refer to SmartFusion Data Sheet for details.
- */
-#define MSS_SPI_REG_CONTROL      (0x00)
-#define MSS_SPI_REG_TXRXDF_SIZE  (0x04)
-#define MSS_SPI_REG_STATUS       (0x08)
-#define MSS_SPI_REG_INT_CLEAR    (0x0c)
-#define MSS_SPI_REG_RX_DATA      (0x10)
-#define MSS_SPI_REG_TX_DATA      (0x14)
-#define MSS_SPI_REG_CLK_GEN      (0x18)
-#define MSS_SPI_REG_SLAVE_SELECT (0x1c)
-#define  MSS_SPI_SSEL_MASK	 (0xff)
-#define  MSS_SPI_DIRECT	   (0x100)
-#define  MSS_SPI_SSELOUT	  (0x200)
-#define MSS_SPI_REG_MIS	  (0x20)
-#define MSS_SPI_REG_RIS	  (0x24)
-#define MSS_SPI_REG_CONTROL2     (0x28)
-#define MSS_SPI_REG_COMMAND      (0x2c)
-#define MSS_SPI_REG_PKTSIZE      (0x30)
-#define MSS_SPI_REG_CMD_SIZE     (0x34)
-#define MSS_SPI_REG_HWSTATUS     (0x38)
-#define MSS_SPI_REG_STAT8	(0x3c)
-#define MSS_SPI_REG_CTRL2	(0x48)
-#define MSS_SPI_REG_FRAMESUP     (0x50)
-
-static inline void mss_spi_hw_tfsz_set(struct mss_spi_dsc *s, int len);
-static void mss_spi_enable_ints(struct mss_spi_dsc *s);
-
-static inline u32 mss_spi_rd(struct mss_spi_dsc *s, unsigned int reg)
+static inline u32 mchp_corespi_read(struct mchp_corespi *spi, unsigned int reg)
 {
-	return readl(s->regs + reg);
+	return readl(spi->regs + reg);
 }
 
-static inline void mss_spi_wr(struct mss_spi_dsc *s, unsigned int reg, u32 val)
+static inline void mchp_corespi_write(struct mchp_corespi *spi, unsigned int reg, u32 val)
 {
-	writel(val, s->regs + reg);
+	writel(val, spi->regs + reg);
 }
 
-static inline void mss_spi_rd_fifo(struct mss_spi_dsc *s)
+static inline void mchp_corespi_enable(struct mchp_corespi *spi)
 {
-	u8 data;
-	int i = 0;
-	int count = min(s->rx_len, MSS_SPI_FIFO_DEPTH);
+	u32 control = mchp_corespi_read(spi, REG_CONTROL);
 
-	/* read whatever is in the FIFO out, up to a maximum of
-	 * rx_len and fifo depth
-	 */
-	while ((i < count) &&
-		!(mss_spi_rd(s, MSS_SPI_REG_STATUS) &
-		  MSS_SPI_STATUS_RXFIFO_EMPTY)) {
-		data = mss_spi_rd(s, MSS_SPI_REG_RX_DATA);
+	control |= CONTROL_ENABLE;
 
-		if (s->rx_buf)
-		*s->rx_buf++ = data;
-		i++;
-	}
-	s->rx_len -= i;
-	s->pending -= i;
+	mchp_corespi_write(spi, REG_CONTROL, control);
 }
 
-static inline void mss_spi_wr_fifo(struct mss_spi_dsc *s)
+static inline void mchp_corespi_disable(struct mchp_corespi *spi)
 {
-	u8 byte;
-	int count;
-	int i = 0;
-
-	/* write a max of the tx len and the fifo depth in this burst */
-	count = min(s->tx_len, MSS_SPI_FIFO_DEPTH);
-	mss_spi_hw_tfsz_set(s, count);
-
-	/* monitor the full next write bit */
-	while ((i < count) &&
-		(!(mss_spi_rd(s, MSS_SPI_REG_STATUS) &
-			MSS_SPI_STATUS_TXFIFO_FULL))) {
-		byte = s->tx_buf ? *s->tx_buf++ : 0xaa;
-		mss_spi_wr(s, MSS_SPI_REG_TX_DATA, byte);
-		i++;
-	}
+	u32 control = mchp_corespi_read(spi, REG_CONTROL);
 
-	s->tx_len -= i;
-	s->pending += i;
-}
+	control &= ~CONTROL_ENABLE;
 
+	mchp_corespi_write(spi, REG_CONTROL, control);
+}
 
-static inline int mss_spi_hw_bt_set(struct mss_spi_dsc *s, int bt)
+static inline void mchp_corespi_read_fifo(struct mchp_corespi *spi)
 {
-	int ret = 0;
-	u32 control;
-	/* disable the SPI controller. Writes to data frame size have
-	 * no effect when the controller is enabled.
-	 */
-	control = mss_spi_rd(s, MSS_SPI_REG_CONTROL);
-	control &= ~MSS_SPI_CONTROL_ENABLE;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
+	u8 data;
+	int fifo_max, i = 0;
 
-	/* set the new data frame size. */
-	mss_spi_wr(s, MSS_SPI_REG_TXRXDF_SIZE, bt);
+	fifo_max = min(spi->rx_len, FIFO_DEPTH);
 
-	/* re-enable the SPI controller */
-	control |= MSS_SPI_CONTROL_ENABLE;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
+	while ((i < fifo_max) && !(mchp_corespi_read(spi, REG_STATUS) & STATUS_RXFIFO_EMPTY)) {
+		data = mchp_corespi_read(spi, REG_RX_DATA);
 
-	return ret;
+		if (spi->rx_buf)
+			*spi->rx_buf++ = data;
+		i++;
+	}
+	spi->rx_len -= i;
+	spi->pending -= i;
 }
 
-static int mss_spi_hw_init(struct mss_spi_dsc *s)
+static void mchp_corespi_enable_ints(struct mchp_corespi *spi)
 {
-	unsigned int ret = 0;
-	u32 control = 0;
+	u32 control, mask = INT_ENABLE_MASK;
 
-	/* Set master mode */
-	control = mss_spi_rd(s, MSS_SPI_REG_CONTROL);
-	control |= MSS_SPI_CONTROL_MASTER;
+	mchp_corespi_disable(spi);
 
-	/* using Motorola SPI mode */
-	control &= ~MSS_SPI_CONTROL_PROTO_MSK;
-	control |= MSS_SPI_CONTROL_PROTO_MOTO;
+	control = mchp_corespi_read(spi, REG_CONTROL);
 
-	mss_spi_hw_bt_set(s, 8);
-	control = mss_spi_rd(s, MSS_SPI_REG_CONTROL);
-	/*
-	 * Set-up the controller so it doesn't remove
-	 * Chip Select until the entire message has been transferred,
-	 * even if at some points TX FIFO becomes empty.
-	 *
-	 * set fifo depth to 32 (for 8 bit xfer)
-	 */
-	control |= MSS_SPI_CONTROL_SPS | MSS_SPI_CONTROL_BIGFIFO;
+	control |= mask;
+	mchp_corespi_write(spi, REG_CONTROL, control);
 
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
+	control |= CONTROL_ENABLE;
+	mchp_corespi_write(spi, REG_CONTROL, control);
+}
 
-	mss_spi_enable_ints(s);
-	control = mss_spi_rd(s, MSS_SPI_REG_CONTROL);
+static void mchp_corespi_disable_ints(struct mchp_corespi *spi)
+{
+	u32 control, mask = INT_ENABLE_MASK;
 
-	control &= ~MSS_SPI_CONTROL_RESET;
-	control |= MSS_SPI_CONTROL_ENABLE;
+	mchp_corespi_disable(spi);
 
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
+	control = mchp_corespi_read(spi, REG_CONTROL);
+	control &= ~mask;
+	mchp_corespi_write(spi, REG_CONTROL, control);
 
-	return ret;
+	control |= CONTROL_ENABLE;
+	mchp_corespi_write(spi, REG_CONTROL, control);
 }
 
-
-/*
- * Set chip select
- * @s		slave
- * @cs		chip select: [0..7]->slave, otherwise->deselect all
- * @returns	0->good,!=0->bad
- */
-static inline int mss_spi_hw_cs_set(struct mss_spi_dsc *s, int cs)
+static inline void mchp_corespi_set_xfer_size(struct mchp_corespi *spi, int len)
 {
-	unsigned int v = (cs >= 0 && cs <= 7) ? (1 << cs) : 0;
-	u32 reg = mss_spi_rd(s, MSS_SPI_REG_SLAVE_SELECT);
+	u32 control;
+	u16 lenpart;
 
-	reg &= ~MSS_SPI_SSEL_MASK;
-	reg |= v;
+	/*
+	 * Disable the SPI controller. Writes to transfer length have
+	 * no effect when the controller is enabled.
+	 */
+	mchp_corespi_disable(spi);
 
-	mss_spi_wr(s, MSS_SPI_REG_SLAVE_SELECT, reg);
+	/*
+	 * The lower 16 bits of the frame count are stored in the control reg
+	 * for legacy reasons, but the upper 16 written to a different register:
+	 * FRAMESUP. While both the upper and lower bits can be *READ* from the
+	 * FRAMESUP register, writing to the lower 16 bits is a NOP
+	 */
+	lenpart = len & 0xffff;
 
-	return 0;
-}
+	control = mchp_corespi_read(spi, REG_CONTROL);
+	control &= ~CONTROL_FRAMECNT_MASK;
+	control |= lenpart << CONTROL_FRAMECNT_SHIFT;
+	mchp_corespi_write(spi, REG_CONTROL, control);
 
-static inline void mss_spi_hw_cs_enable_direct_mode(struct mss_spi_dsc *s)
-{
-	u32 reg = mss_spi_rd(s, MSS_SPI_REG_SLAVE_SELECT);
+	lenpart = len & 0xffff0000;
+	mchp_corespi_write(spi, REG_FRAMESUP, lenpart);
 
-	reg |= MSS_SPI_DIRECT;
-	mss_spi_wr(s, MSS_SPI_REG_SLAVE_SELECT, reg);
+	control |= CONTROL_ENABLE;
+	mchp_corespi_write(spi, REG_CONTROL, control);
 }
 
-static inline void mss_spi_hw_cs_disable_direct_mode(struct mss_spi_dsc *s)
+static inline void mchp_corespi_write_fifo(struct mchp_corespi *spi)
 {
-	u32 reg = mss_spi_rd(s, MSS_SPI_REG_SLAVE_SELECT);
+	u8 byte;
+	int fifo_max, i = 0;
+
+	fifo_max = min(spi->tx_len, FIFO_DEPTH);
+	mchp_corespi_set_xfer_size(spi, fifo_max);
+
+	while ((i < fifo_max) && !(mchp_corespi_read(spi, REG_STATUS) & STATUS_TXFIFO_FULL)) {
+		byte = spi->tx_buf ? *spi->tx_buf++ : 0xaa;
+		mchp_corespi_write(spi, REG_TX_DATA, byte);
+		i++;
+	}
 
-	reg &= ~MSS_SPI_DIRECT;
-	mss_spi_wr(s, MSS_SPI_REG_SLAVE_SELECT, reg);
+	spi->tx_len -= i;
+	spi->pending += i;
 }
 
-static inline void mss_spi_activate_cs(struct mss_spi_dsc *s)
+static inline void mchp_corespi_set_framesize(struct mchp_corespi *spi, int bt)
 {
-	u32 reg = mss_spi_rd(s, MSS_SPI_REG_SLAVE_SELECT);
+	u32 control;
+
+	/*
+	 * Disable the SPI controller. Writes to the frame size have
+	 * no effect when the controller is enabled.
+	 */
+	mchp_corespi_disable(spi);
 
-	reg |= MSS_SPI_SSELOUT;
-	mss_spi_wr(s, MSS_SPI_REG_SLAVE_SELECT, reg);
+	mchp_corespi_write(spi, REG_FRAME_SIZE, bt);
+
+	control = mchp_corespi_read(spi, REG_CONTROL);
+	control |= CONTROL_ENABLE;
+	mchp_corespi_write(spi, REG_CONTROL, control);
 }
 
-static inline void mss_spi_deactivate_cs(struct mss_spi_dsc *s)
+static void mchp_corespi_set_cs(struct spi_device *spi, bool disable)
 {
-	u32 reg = mss_spi_rd(s, MSS_SPI_REG_SLAVE_SELECT);
+	u32 reg;
+	struct mchp_corespi *corespi = spi_master_get_devdata(spi->master);
+
+	reg = mchp_corespi_read(corespi, REG_SLAVE_SELECT);
+	reg &= ~BIT(spi->chip_select);
+	reg |= !disable << spi->chip_select;
 
-	reg &= ~MSS_SPI_SSELOUT;
-	mss_spi_wr(s, MSS_SPI_REG_SLAVE_SELECT, reg);
+	mchp_corespi_write(corespi, REG_SLAVE_SELECT, reg);
 }
 
-/*
- * Set controller clock rate
- * @s		slave
- * @returns	0->good,!=0->bad
- */
-static inline int mss_spi_clk_gen_set(struct mss_spi_dsc *s)
+static int mchp_corespi_setup(struct spi_device *spi)
 {
-	u32 control = mss_spi_rd(s, MSS_SPI_REG_CONTROL);
-	control &= ~MSS_SPI_CONTROL_ENABLE;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
-
-	if (s->clk_mode)
-		control |= MSS_SPI_CONTROL_CLKMODE;
-	else
-		control &= ~MSS_SPI_CONTROL_CLKMODE;
+	struct mchp_corespi *corespi = spi_master_get_devdata(spi->master);
+	u32 reg;
 
-	mss_spi_wr(s, MSS_SPI_REG_CLK_GEN, s->clk_gen);
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control | MSS_SPI_CONTROL_ENABLE);
+	/*
+	 * Active high slaves need to be specifically set to their inactive
+	 * states during probe by adding them to the "control group" & thus
+	 * driving their select line low.
+	 */
+	if (spi->mode & SPI_CS_HIGH) {
+		reg = mchp_corespi_read(corespi, REG_SLAVE_SELECT);
+		reg |= BIT(spi->chip_select);
+		mchp_corespi_write(corespi, REG_SLAVE_SELECT, reg);
+	}
 	return 0;
 }
 
-static void mss_spi_enable_ints(struct mss_spi_dsc *s)
+static void mchp_corespi_init(struct spi_master *master, struct mchp_corespi *spi)
 {
-	u32 control;
-	u32 mask = MSS_SPI_CONTROL_RX_DATA_INT |
-		   MSS_SPI_CONTROL_TX_DATA_INT |
-		   MSS_SPI_CONTROL_RX_OVER_INT |
-		   MSS_SPI_CONTROL_TX_UNDER_INT;
+	unsigned long clk_hz;
+	u32 reg, control = mchp_corespi_read(spi, REG_CONTROL);
 
-	control = mss_spi_rd(s, MSS_SPI_REG_CONTROL);
-	control &= ~MSS_SPI_CONTROL_ENABLE;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
+	control |= CONTROL_MASTER;
 
-	control |= mask;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
-	control |= MSS_SPI_CONTROL_ENABLE;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
-}
+	control &= ~CONTROL_MODE_MASK;
+	control |= MOTOROLA_MODE;
 
-static void mss_spi_disable_ints(struct mss_spi_dsc *s)
-{
-	u32 control;
-	u32 mask = MSS_SPI_CONTROL_RX_DATA_INT |
-		   MSS_SPI_CONTROL_TX_DATA_INT |
-		   MSS_SPI_CONTROL_RX_OVER_INT |
-		   MSS_SPI_CONTROL_TX_UNDER_INT;
-
-	mask = ~mask;
-	control = mss_spi_rd(s, MSS_SPI_REG_CONTROL);
-	control &= ~MSS_SPI_CONTROL_ENABLE;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
-
-	control &= mask;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control | MSS_SPI_CONTROL_ENABLE);
-}
+	mchp_corespi_set_framesize(spi, DEFAULT_FRAMESIZE);
 
-/*
- * Set transfer length
- * @s		slave
- * @len		transfer size
- */
-static inline void mss_spi_hw_tfsz_set(struct mss_spi_dsc *s, int len)
-{
-	u32 control;
-	u16 lenpart;
+	/* max. possible spi clock rate is the apb clock rate */
+	clk_hz = clk_get_rate(spi->clk);
+	master->max_speed_hz = clk_hz;
 
 	/*
-	 * Disable the SPI controller. Writes to transfer length have
-	 * no effect when the controller is enabled.
+	 * The controller must be configured so that it doesn't remove Chip
+	 * Select until the entire message has been transferred, even if at
+	 * some points TX FIFO becomes empty.
+	 *
+	 * BIGFIFO mode is also enabled, which sets the fifo depth to 32 frames
+	 * for the 8 bit transfers that this driver uses.
 	 */
-	control = mss_spi_rd(s, MSS_SPI_REG_CONTROL);
-	control &= ~MSS_SPI_CONTROL_ENABLE;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
+	control = mchp_corespi_read(spi, REG_CONTROL);
+	control |= CONTROL_SPS | CONTROL_BIGFIFO;
 
-	/*
-	 * Set the new transfer size.
-	 */
+	mchp_corespi_write(spi, REG_CONTROL, control);
+
+	mchp_corespi_enable_ints(spi);
 
 	/*
-	 * write the lower 16 bits first
+	 * It is required to enable direct mode, otherwise control over the chip
+	 * select is relinquished to the hardware. SSELOUT is enabled too so we
+	 * can deal with active high slaves.
 	 */
-	lenpart = len & 0xffff;
+	mchp_corespi_write(spi, REG_SLAVE_SELECT, SSELOUT | SSEL_DIRECT);
 
-	control &= ~MSS_SPI_CONTROL_CNT_MSK;
-	control |= lenpart << MSS_SPI_CONTROL_CNT_SHF;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
+	control = mchp_corespi_read(spi, REG_CONTROL);
 
-	/*
-	 * write the upper 16 bits now
-	 */
-	lenpart = len & 0xffff0000;
-	mss_spi_wr(s, MSS_SPI_REG_FRAMESUP, lenpart);
+	control &= ~CONTROL_RESET;
+	control |= CONTROL_ENABLE;
 
-	/*
-	 * Re-enable the SPI controller
-	 */
-	control |= MSS_SPI_CONTROL_ENABLE;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
+	mchp_corespi_write(spi, REG_CONTROL, control);
 }
 
-/*
- * Set SPI mode
- * @s		slave
- * @mode	mode
- * @returns	0->good;!=0->bad
- */
-static inline int mss_spi_hw_mode_set(struct mss_spi_dsc *s, unsigned int mode)
+static inline void mchp_corespi_set_clk_gen(struct mchp_corespi *spi)
 {
-	u32 control = mss_spi_rd(s, MSS_SPI_REG_CONTROL);
-
-	control &= ~MSS_SPI_CONTROL_ENABLE;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
+	u32 control;
 
-	/* set the mode */
-	if (mode & SPI_CPHA)
-		control |= MSS_SPI_CONTROL_SPH;
-	else
-		control &= ~MSS_SPI_CONTROL_SPH;
+	mchp_corespi_disable(spi);
 
-	if (mode & SPI_CPOL)
-		control |= MSS_SPI_CONTROL_SPO;
+	control = mchp_corespi_read(spi, REG_CONTROL);
+	if (spi->clk_mode)
+		control |= CONTROL_CLKMODE;
 	else
-		control &= ~MSS_SPI_CONTROL_SPO;
+		control &= ~CONTROL_CLKMODE;
 
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
-
-	control |= MSS_SPI_CONTROL_ENABLE;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
-	return 0;
+	mchp_corespi_write(spi, REG_CLK_GEN, spi->clk_gen);
+	mchp_corespi_write(spi, REG_CONTROL, control);
+	mchp_corespi_write(spi, REG_CONTROL, control | CONTROL_ENABLE);
 }
 
-/*
- * Shut down the SPI controller
- * @s		SPI slave
- */
-static void mss_spi_hw_release(struct mss_spi_dsc *s)
+static inline void mchp_corespi_set_mode(struct mchp_corespi *spi, unsigned int mode)
 {
-	u32 control = mss_spi_rd(s, MSS_SPI_REG_CONTROL);
+	u32 control, mode_val;
+
+	switch (mode & SPI_MODE_X_MASK) {
+	case SPI_MODE_0:
+		mode_val = 0;
+		break;
+	case SPI_MODE_1:
+		mode_val = CONTROL_SPH;
+		break;
+	case SPI_MODE_2:
+		mode_val = CONTROL_SPO;
+		break;
+	case SPI_MODE_3:
+		mode_val = CONTROL_SPH | CONTROL_SPO;
+		break;
+	}
 
 	/*
-	 * Disable the SPI controller
+	 * Disable the SPI controller. Writes to the frame size have
+	 * no effect when the controller is enabled.
 	 */
-	control &= ~MSS_SPI_CONTROL_ENABLE;
-	mss_spi_wr(s, MSS_SPI_REG_CONTROL, control);
-}
+	mchp_corespi_disable(spi);
 
+	control = mchp_corespi_read(spi, REG_CONTROL);
+	control &= ~(SPI_MODE_X_MASK << MODE_X_MASK_SHIFT);
+	control |= mode_val;
 
-/*
- * Interrupt handler
- */
-static irqreturn_t mss_spi_interrupt(int irq, void *dev_id)
+	mchp_corespi_write(spi, REG_CONTROL, control);
+
+	control |= CONTROL_ENABLE;
+	mchp_corespi_write(spi, REG_CONTROL, control);
+}
+
+static irqreturn_t mchp_corespi_interrupt(int irq, void *dev_id)
 {
 	struct spi_master *master = dev_id;
-	struct mss_spi_dsc *s = spi_master_get_devdata(master);
-	irqreturn_t ret = IRQ_HANDLED;
-
-	int intfield = mss_spi_rd(s, MSS_SPI_REG_MIS) & 0xf;
+	struct mchp_corespi *spi = spi_master_get_devdata(master);
+	u32 intfield = mchp_corespi_read(spi, REG_MIS) & 0xf;
+	bool finalise = false;
 
 	/* Interrupt line may be shared and not for us at all */
 	if (intfield == 0)
 		return IRQ_NONE;
 
-	/* clear the interrupt conditions */
-	if (intfield & MSS_SPI_INT_TXDONE) {
-		mss_spi_wr(s, MSS_SPI_REG_INT_CLEAR,
-			MSS_SPI_INT_TXDONE);
-		/* check if we have data to read */
-		if (s->rx_len)
-			mss_spi_rd_fifo(s);
-		/* check if we have data to write */
-		if (s->tx_len)
-			mss_spi_wr_fifo(s);
-
-		/* if rx_len is 0 then wake up completion */
-		if (!s->rx_len)
-			complete(&master->xfer_completion);
+	if (intfield & INT_TXDONE) {
+		mchp_corespi_write(spi, REG_INT_CLEAR, INT_TXDONE);
+
+		if (spi->rx_len)
+			mchp_corespi_read_fifo(spi);
+
+		if (spi->tx_len)
+			mchp_corespi_write_fifo(spi);
+
+		if (!spi->rx_len)
+			finalise = true;
 	}
 
-	if (intfield & MSS_SPI_INT_RXRDY)
-		mss_spi_wr(s, MSS_SPI_REG_INT_CLEAR, MSS_SPI_INT_RXRDY);
+	if (intfield & INT_RXRDY)
+		mchp_corespi_write(spi, REG_INT_CLEAR, INT_RXRDY);
 
-	if (intfield & MSS_SPI_INT_RX_CH_OVRFLW) {
-		mss_spi_wr(s, MSS_SPI_REG_INT_CLEAR,
-			MSS_SPI_INT_RX_CH_OVRFLW);
-		complete(&master->xfer_completion);
+	if (intfield & INT_RX_CHANNEL_OVERFLOW) {
+		mchp_corespi_write(spi, REG_INT_CLEAR, INT_RX_CHANNEL_OVERFLOW);
+		finalise = true;
 		dev_err(&master->dev,
 			"%s: RX OVERFLOW: rxlen: %d, txlen: %d\n", __func__,
-			s->rx_len, s->tx_len);
+			spi->rx_len, spi->tx_len);
 	}
 
-	if (intfield & MSS_SPI_INT_TX_CH_UNDRUN) {
-		mss_spi_wr(s, MSS_SPI_REG_INT_CLEAR,
-			MSS_SPI_INT_TX_CH_UNDRUN);
-		complete(&master->xfer_completion);
+	if (intfield & INT_TX_CHANNEL_UNDERRUN) {
+		mchp_corespi_write(spi, REG_INT_CLEAR, INT_TX_CHANNEL_UNDERRUN);
+		finalise = true;
 		dev_err(&master->dev,
 			"%s: TX UNDERFLOW: rxlen: %d, txlen: %d\n", __func__,
-			s->rx_len, s->tx_len);
+			spi->rx_len, spi->tx_len);
 	}
 
+	if (finalise)
+		spi_finalize_current_transfer(master);
 
-	return ret;
-}
-
-
-static int mss_spi_transfer_one_irq(struct spi_master *master,
-				    struct spi_device *spi,
-				    struct spi_transfer *tfr)
-{
-	struct mss_spi_dsc *s = spi_master_get_devdata(master);
-
-	/* enable interrupts and fill in registers and fifos */
-	if (s->tx_len)
-		mss_spi_wr_fifo(s);
-
-	return 1;
+	return IRQ_HANDLED;
 }
 
-static int mss_spi_transfer_one(struct spi_master *master,
-				struct spi_device *spi,
-				struct spi_transfer *tfr)
+static int mchp_corespi_calculate_clkgen(struct mchp_corespi *spi,
+					 unsigned long target_hz)
 {
-	struct mss_spi_dsc *s = spi_master_get_devdata(master);
-	unsigned long spi_hz, clk_hz, clk_gen;
-
-	/* set clock */
-	clk_hz = clk_get_rate(s->clk);
-
-	/* find suitable clock */
-	spi_hz = min(tfr->speed_hz, master->max_speed_hz);
+	unsigned long clk_hz, spi_hz, clk_gen;
 
-	if ((spi_hz == 0) || (spi_hz < master->min_speed_hz)) {
-		dev_err(&spi->dev, "%s: %ld hz too slow\n",
-			__func__, spi_hz);
+	clk_hz = clk_get_rate(spi->clk);
+	if (!clk_hz)
 		return -EINVAL;
-	}
-
-	/* calculate clock divider */
-	if (spi_hz >= clk_hz / 2) {
-		dev_err(&spi->dev,
-			"%s: %ld hz too fast for system clock %ld Hz\n",
-			__func__, spi_hz, clk_hz);
-		return -EINVAL; /* spi rate too fast for chip */
-	}
+	spi_hz = min(target_hz, clk_hz);
 
+	/*
+	 * There are two possible clock modes for the controller generated
+	 * clock's division ratio:
+	 * CLK_MODE = 0: 1 / (2^(CLK_GEN + 1)) where CLK_GEN = 0 to 15.
+	 * CLK_MODE = 1: 1 / (2 * CLK_GEN + 1) where CLK_GEN = 0 to 255.
+	 * First try mode 1, fall back to 0 and if we have tried both modes and
+	 * we /still/ can't get a good setting, we then throw the toys out of
+	 * the pram and give up
+	 * clk_gen is the register name for the clock divider on MPFS.
+	 */
 	clk_gen = DIV_ROUND_UP(clk_hz, 2 * spi_hz) - 1;
-	if ((clk_gen > MSS_SPI_CLK_GEN_MAX) ||
-	    (clk_gen <= MSS_SPI_CLK_GEN_MIN)) {
-		/* use alternate mode */
+	if (clk_gen > CLK_GEN_MODE1_MAX || clk_gen <= CLK_GEN_MIN) {
 		clk_gen = DIV_ROUND_UP(clk_hz, spi_hz);
 		clk_gen = fls(clk_gen) - 1;
-		if ((clk_gen > MSS_SPI_CLK_GEN_P2_MAX) ||
-		    (clk_gen < MSS_SPI_CLK_GEN_MIN))
-			return -EINVAL; /* give up */
-		s->clk_gen = clk_gen;
-		s->clk_mode = 0;
-	} else {
-		s->clk_gen = clk_gen;
-		s->clk_mode = 1;
-	}
 
-	/* calculate spi_hz obtained */
-	if (s->clk_mode)
-		spi_hz = clk_hz / (2 * (s->clk_gen + 1));
-	else
-		spi_hz = clk_hz / (2 ^ (s->clk_gen + 1));
+		if (clk_gen > CLK_GEN_MODE0_MAX)
+			return -EINVAL;
 
-	if (mss_spi_clk_gen_set(s)) {
-		dev_err(&spi->dev, "can't set clk divider\n");
-		return -EINVAL;
+		spi->clk_mode = 0;
+	} else {
+		spi->clk_mode = 1;
 	}
 
-	/* set transmit buffers and length */
-	s->tx_buf = tfr->tx_buf;
-	s->rx_buf = tfr->rx_buf;
-	s->tx_len = tfr->len;
-	s->rx_len = tfr->len;
-	s->pending = 0;
-
-	mss_spi_hw_tfsz_set(s, (s->tx_len > MSS_SPI_FIFO_DEPTH)
-			? MSS_SPI_FIFO_DEPTH : s->tx_len);
+	spi->clk_gen = clk_gen;
+	return 0;
 
-	/* run in interrupt mode */
-	return mss_spi_transfer_one_irq(master, spi, tfr);
 }
 
-
-static int mss_spi_prepare_message(struct spi_master *master,
-				   struct spi_message *msg)
+static int mchp_corespi_transfer_one(struct spi_master *master,
+				     struct spi_device *spi_dev,
+				     struct spi_transfer *xfer)
 {
-	struct spi_device *spi = msg->spi;
-	struct mss_spi_dsc *s = spi_master_get_devdata(master);
-	int ret = 0;
+	struct mchp_corespi *spi = spi_master_get_devdata(master);
+	int ret;
 
-	/*
-	 * set for this message: frame size, clock, slave select, mode
-	 */
-	if (mss_spi_hw_bt_set(s, 8)) {
-		dev_err(&spi->dev, "unsupported frame size: %d\n",
-			8);
-		ret = -EINVAL;
-		goto done;
+	ret = mchp_corespi_calculate_clkgen(spi, (unsigned long) xfer->speed_hz);
+	if (ret) {
+		dev_err(&master->dev, "failed to set clk_gen for target %u Hz\n", xfer->speed_hz);
+		return ret;
 	}
 
-	if (mss_spi_hw_cs_set(s, spi->chip_select)) {
-		dev_err(&spi->dev, "incorrect chip select: %d\n",
-			spi->chip_select);
-		ret = -EINVAL;
-		goto done;
-	}
+	mchp_corespi_set_clk_gen(spi);
 
-	mss_spi_hw_cs_enable_direct_mode(s);
-	mss_spi_activate_cs(s);
+	spi->tx_buf = xfer->tx_buf;
+	spi->rx_buf = xfer->rx_buf;
+	spi->tx_len = xfer->len;
+	spi->rx_len = xfer->len;
+	spi->pending = 0;
 
-	if (mss_spi_hw_mode_set(s, spi->mode)) {
-		dev_err(&spi->dev, "unsupported mode: %x\n", spi->mode);
-		ret = -EINVAL;
-		goto done;
-	}
+	mchp_corespi_set_xfer_size(spi, (spi->tx_len > FIFO_DEPTH)
+				   ? FIFO_DEPTH : spi->tx_len);
 
-done:
-	return ret;
+	if (spi->tx_len)
+		mchp_corespi_write_fifo(spi);
+	return 1;
 }
 
-
-static int mss_spi_unprepare_message(struct spi_master *master,
-				     struct spi_message *msg)
+static int mchp_corespi_prepare_message(struct spi_master *master,
+					struct spi_message *msg)
 {
-	struct mss_spi_dsc *s = spi_master_get_devdata(master);
+	struct spi_device *spi_dev = msg->spi;
+	struct mchp_corespi *spi = spi_master_get_devdata(master);
 
-	mss_spi_deactivate_cs(s);
-	mss_spi_hw_cs_disable_direct_mode(s);
+	mchp_corespi_set_framesize(spi, DEFAULT_FRAMESIZE);
+	mchp_corespi_set_mode(spi, spi_dev->mode);
 
 	return 0;
 }
 
-static void mss_spi_handle_err(struct spi_master *master,
-				     struct spi_message *msg)
+static int mchp_corespi_probe(struct platform_device *pdev)
 {
-	struct mss_spi_dsc *s = spi_master_get_devdata(master);
-	mss_spi_deactivate_cs(s);
-	mss_spi_hw_cs_disable_direct_mode(s);
-}
-
-
-/*
- * Instantiate a new instance of the SPI controller
- * @dev		SPI controller platform device
- * @returns	0->success, <0->error code
- */
-static int mss_spi_probe(struct platform_device *pdev)
-{
-	struct spi_master *master = NULL;
-	struct mss_spi_dsc *s = NULL;
+	struct spi_master *master;
+	struct mchp_corespi *spi;
 	struct resource *res;
+	u32 num_cs;
 	int ret = 0;
-	int err;
-	u32 val;
-
-	/* allocate a spi master */
-	master = spi_alloc_master(&pdev->dev, sizeof(*s));
-	if (!master) {
-		dev_err(&pdev->dev, "unable to allocate master for SPI controller\n");
-		return -ENOMEM;
-	}
 
-	platform_set_drvdata(pdev, master);
-	master->mode_bits = SPI_CPOL | SPI_CPHA;
-	master->bits_per_word_mask = SPI_BPW_MASK(8);
-	master->num_chipselect = -1;
-	master->transfer_one = mss_spi_transfer_one;
-	master->handle_err = mss_spi_handle_err;
-	master->prepare_message = mss_spi_prepare_message;
-	master->unprepare_message = mss_spi_unprepare_message;
+	master = devm_spi_alloc_master(&pdev->dev, sizeof(*spi));
+	if (!master)
+		return dev_err_probe(&pdev->dev, -ENOMEM,
+				     "unable to allocate master for SPI controller\n");
 
-	/* set up of_node so slaves can enumerate */
-	master->dev.of_node = pdev->dev.of_node;
+	platform_set_drvdata(pdev, master);
 
-	/* pointer to the controller-specific data structure */
-	s = spi_master_get_devdata(master);
+	if (of_property_read_u32(pdev->dev.of_node, "num-cs", &num_cs))
+		num_cs = MAX_CS;
 
-	/*
-	 * Get platform data
-	 */
+	master->num_chipselect = num_cs;
+	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
+	master->setup = mchp_corespi_setup;
+	master->bits_per_word_mask = SPI_BPW_MASK(8);
+	master->transfer_one = mchp_corespi_transfer_one;
+	master->prepare_message = mchp_corespi_prepare_message;
+	master->set_cs = mchp_corespi_set_cs;
+	master->dev.of_node = pdev->dev.of_node;
 
-	/* get the register bases, and IRQ from the platform device */
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "no register base for SPI controller\n");
-		ret = -ENXIO;
-		goto error_release_nothing;
-	}
+	spi = spi_master_get_devdata(master);
 
-	/* map in the controller registers */
-	s->regs = ioremap(res->start, resource_size(res));
-	if (!s->regs) {
-		dev_err(&pdev->dev,
-			"unable to map registers for SPI controller, base=%08llx\n",
-			res->start);
-		ret = -EINVAL;
-		goto error_release_master;
-	}
+	spi->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+	if (IS_ERR(spi->regs))
+		return PTR_ERR(spi->regs);
 
-	/* get irq */
-	s->irq = platform_get_irq(pdev, 0);
-	if (s->irq <= 0) {
-		dev_err(&pdev->dev,
-			"invalid IRQ %d for SPI controller\n",
-			s->irq);
-		ret = -ENXIO;
-		goto error_release_regs;
-	}
+	spi->irq = platform_get_irq(pdev, 0);
+	if (spi->irq <= 0)
+		return dev_err_probe(&pdev->dev, -ENXIO,
+				     "invalid IRQ %d for SPI controller\n",
+				     spi->irq);
 
-	err = devm_request_irq(&pdev->dev, s->irq,
-				mss_spi_interrupt,
-				IRQF_SHARED,
-				dev_name(&pdev->dev), master);
-	if (err) {
-		dev_err(&pdev->dev, "could not request irq: %d\n", err);
-		goto error_release_regs;
-	}
+	ret = devm_request_irq(&pdev->dev, spi->irq, mchp_corespi_interrupt,
+			       IRQF_SHARED, dev_name(&pdev->dev), master);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret,
+				     "could not request irq: %d\n", ret);
 
-	s->clk = devm_clk_get(&pdev->dev, NULL);
-	if ((!s->clk) || (IS_ERR(s->clk))) {
-		err = PTR_ERR(s->clk);
-		dev_err(&pdev->dev, "could not get clk: %d\n", err);
-		goto error_release_regs;
-	}
+	spi->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(spi->clk))
+		return dev_err_probe(&pdev->dev, PTR_ERR(spi->clk),
+				     "could not get clk: %d\n", ret);
 
-	err = clk_prepare_enable(s->clk);
-	if (err) {
-		dev_err(&pdev->dev, "failed to enable clock\n");
-		return err;
-	}
+	ret = clk_prepare_enable(spi->clk);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret,
+				     "failed to enable clock\n");
 
-	/* get master's max spi clock rate  from DT */
-	err = of_property_read_u32(pdev->dev.of_node,
-		"spi-max-frequency",
-		&master->max_speed_hz);
-	if (err)
-		/* default to sensible clock */
-		master->max_speed_hz = 140000000;
-
-	/* get master's num-cs */
-	err = of_property_read_u32(pdev->dev.of_node, "num-cs", &val);
-	if (err)
-		master->num_chipselect = MSS_SPI_MAX_CS;
-	else
-		master->num_chipselect = (u16)val;
-
-	/* initialize the controller hardware */
-	if (mss_spi_hw_init(s)) {
-		dev_err(&pdev->dev,
-			"unable to initialize hardware for SPI controller\n");
-		ret = -ENXIO;
-		goto error_release_irq;
-	}
+	mchp_corespi_init(master, spi);
 
-	/* register the SPI controller */
 	ret = devm_spi_register_master(&pdev->dev, master);
 	if (ret) {
-		dev_err(&pdev->dev,
-			"unable to register master for SPI controller\n");
-		goto error_release_hardware;
+		mchp_corespi_disable(spi);
+		clk_disable_unprepare(spi->clk);
+		return dev_err_probe(&pdev->dev, ret,
+				     "unable to register master for SPI controller\n");
 	}
 
-	/* if we are here, we are successful */
-	dev_info(&pdev->dev, "Microsemi SPI Controller %d up\n",
-		master->bus_num);
-
-	goto done;
-
-	/* error processing */
-error_release_hardware:
-	mss_spi_hw_release(s);
-error_release_irq:
-	free_irq(s->irq, s);
-error_release_regs:
-	iounmap(s->regs);
-error_release_master:
-	spi_master_put(master);
-	platform_set_drvdata(pdev, NULL);
-error_release_nothing:
-done:
-	return ret;
+	dev_info(&pdev->dev, "Registered SPI controller %d\n", master->bus_num);
+
+	return 0;
 }
 
-/*
- * Shutdown of an instance of the controller device
- * @dev		SPI controller platform device
- * @returns	0->success, <0->error code
- */
-static int mss_spi_remove(struct platform_device *pdev)
+static int mchp_corespi_remove(struct platform_device *pdev)
 {
 	struct spi_master *master  = platform_get_drvdata(pdev);
-	struct mss_spi_dsc *s = spi_master_get_devdata(master);
+	struct mchp_corespi *spi = spi_master_get_devdata(master);
 
-	mss_spi_disable_ints(s);
-	/* release kernel resources */
-	spi_unregister_master(master);
-	free_irq(s->irq, s);
-	iounmap(s->regs);
-	spi_master_put(master);
-	clk_disable_unprepare(s->clk);
-	platform_set_drvdata(pdev, NULL);
-
-	/* shut the hardware down */
-	mss_spi_hw_release(s);
+	mchp_corespi_disable_ints(spi);
+	clk_disable_unprepare(spi->clk);
+	mchp_corespi_disable(spi);
 
 	return 0;
 }
 
-#define MICROSEMI_SPI_PM_OPS (NULL)
+#define MICROCHIP_SPI_PM_OPS (NULL)
 
 /*
  * Platform driver data structure
  */
 
-
 #if defined(CONFIG_OF)
-static const struct of_device_id mss_spi_dt_ids[] = {
-	{ .compatible = "microsemi,ms-pf-mss-spi" },
+static const struct of_device_id mchp_corespi_dt_ids[] = {
 	{ .compatible = "microchip,mpfs-spi" },
 	{ /* sentinel */ }
 };
-MODULE_DEVICE_TABLE(of, mss_spi_dt_ids);
+MODULE_DEVICE_TABLE(of, mchp_corespi_dt_ids);
 #endif
 
-static struct platform_driver mss_spi_driver = {
-	.probe = mss_spi_probe,
+static struct platform_driver mchp_corespi_driver = {
+	.probe = mchp_corespi_probe,
 	.driver = {
-		.name = "microsemi-mss-spi",
-		.pm = MICROSEMI_SPI_PM_OPS,
-		.of_match_table = of_match_ptr(mss_spi_dt_ids),
+		.name = "microchip-corespi",
+		.pm = MICROCHIP_SPI_PM_OPS,
+		.of_match_table = of_match_ptr(mchp_corespi_dt_ids),
 		.owner = THIS_MODULE,
 	},
-	.remove = mss_spi_remove,
+	.remove = mchp_corespi_remove,
 };
-module_platform_driver(mss_spi_driver);
-MODULE_AUTHOR("Microsemi Corporation");
-MODULE_DESCRIPTION("Microsemi MSS SPI driver");
-MODULE_LICENSE("GPL");
+module_platform_driver(mchp_corespi_driver);
+MODULE_DESCRIPTION("Microchip coreSPI SPI controller driver");
+MODULE_AUTHOR("Daire McNamara <daire.mcnamara@microchip.com>");
+MODULE_AUTHOR("Conor Dooley <conor.dooley@microchip.com>");
+MODULE_LICENSE("GPL");
\ No newline at end of file
-- 
2.25.1

